<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>9-1-8</title>
  <script>
    /* 
      메소드
      - 객체의 속성 중 함수로 정의된 속성
      - 내부적으로 메소드가 중복되지 않고 하나만 생성!!(class를 사용하는 이유!!)

      class 클래스이름{
        메소드1 () {...}
        메소드2 () {...}
      }


      *단순 객체 생성의 단점 : 객체 별로 메소드를 생성하기 때문에 무거운 자료형이 여러 번 생성.
      (9-1-5.html 가 단순 객체 생성 예시)
    */
   

    //클래스 생성
    class Student {
      //생성자 
      constructor (이름, 국어, 영어, 수학, 과학){
        this.이름 = 이름,
        this.국어 = 국어,
        this.영어 = 영어,
        this.수학 = 수학,
        this.과학 = 과학
      }
      
      getSum () {
        return this.국어 + this.영어 + this.수학 + this.과학
      }

      getAverage () {
        return this.getSum() / 4
      }

      toString () {
        return `${this.이름}\t${this.getSum()}점\t${this.getAverage()}점\n`
      }
    }

    //객체 선언
    const students = []
    students.push(new Student('구름',87,98,88,90))
    students.push(new Student('별이', 92, 98, 96, 88))
    students.push(new Student('겨울', 76, 96, 94, 86))
    students.push(new Student('바다', 98, 52, 98, 92))

    // console.log(students)
    /* 
    클래스의 경우 단순 객체 생성과 달리 생성자만 초기화 되어 있는 걸 확인할 수 있다.
    (단순 객체 생성은 각 배열의 내부에 메소드가 추가되었다.)
    
    0: Student {이름: "구름", 국어: 87, 영어: 98, 수학: 88, 과학: 90}
    1: Student {이름: "별이", 국어: 92, 영어: 98, 수학: 96, 과학: 88}
    2: Student {이름: "겨울", 국어: 76, 영어: 96, 수학: 94, 과학: 86}
    3: Student {이름: "바다", 국어: 98, 영어: 52, 수학: 98, 과학: 92}
    
    */
   
   
   //출력
   let output = '이름\t총점\t평균\n'
   
   for(const s of students){
     output += s.toString()
    }
    
    console.log(output)
    



  </script>
</head>
<body>
  
</body>
</html>