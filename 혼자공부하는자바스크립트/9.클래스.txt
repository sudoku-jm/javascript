<클래스의 기본 기능>

1. 추상화
- 프로그램에 필요한 요소만 사용해서 객체를 표현
- 핵심적인 개념, 공통적인 특성, 업무적 요소를 추려내는 것.

2. 객체 만들기
- 학생 성적 관리 프로그램 개발
  필요 객체 : 학생
  필요 요소 : 이름, 과목별 성적 등
  필요한 공통사항만 추출 => "추상화"

-Review
  객체 선언 :  const 객체명 = {속성1 : 값1 , 속성1 : 값2}
  객체 속성 참조 : 객체명['속성'] or 객체명.속성
  객체 속성 추가 : 객체명.속성 = 값
  객체 속성 제거 : delete 객체명.속성


3. 객체를 처리하는 함수
- 특정 객체를 이용하는 코드는 함수로 정의하는 것이 좋음
- 코드의 재사용성과 확장성을 높여준다.
- 특정 객체에 대한 기능이 확장 및 변경되었을 때, 관련 함수만 수정할 수 있기때문에 유지보수가 쉬워진다.

//객체선언
const obj = {} 
//객체 처리하는 함수 정의
function getSomethingOf(obj){

}


4.객체의 기능을 메소드로 추가하기
[객체A] - 기능A() , 기능B()
[객체B] - 기능A() , 기능B()
기능A()가 어떤 객체에 대한 기능인지 혼동 => 함수를 객체 내부의 메소드로 추가하기

const 객체A = {}
const 객체B = {}

객체A.기능A = function() {
  //객체A에 대한 기능A
}
객체B.기능A = function() {
  //객체B에 대한 기능A
}

- 객체를 생성하는 함수
  : 함수 내부에서 객체를 생성하고 반환하는 함수
  : 장점 - 중복될 수 있는 코드를 최소화.
         - 객체 생성에 대한 유지봇가 쉬움.
  : 단점 - 객체 별로 메소드를 생성하기 때문에 무거운 자료형이 여러 번 생성.
         - 유사한 객체를 생성하는 함수를 만들게 되면, 코드의 중복이 늘어남.


5. 단순 객체 생성의 비효율성

사람{
  속성1 : 이름
  속성2 : 나이
  메소드1 : 일하기()
}
학생{
  속성1 : 이름 //중복
  속성2 : 나이 //중복
  속성3 : 학번
  속성4 : 전공
  메소드1 : 일하기() //중복
  메소드2 : 공부하기()
}
교수{
  속성1 : 이름 //중복
  속성2 : 나이 //중복
  속성3 : 교수번호
  속성4 : 전공 //중복
  메소드1 : 일하기()  //중복
  메소드2 : 공부하기()  //중복
  메소드3 : 연구하기()
  메소드4 : 강의하기()
}




6.클래스 선언하기

- 객체 지향 프로그래밍 : 객체를 정의하고 활용해서 프로그램을 만드는 방식
- 객체를 생성하는 방법
  클래스 class : 지원도 많지만 제한도 많다
  프로토타입 prototype :  지원도 없지만 제한도 없음

* javascript에는 class 개념이 없었다.
초기에는 prototype문법으로 객체를 생성
ECMA6표준부터 class 문법이 추가


- 클래스(class) : 객체를 생성하기 위한 템플릿
- 인스턴스 (객체) : 클래스 기반으로 생성된 객체

//클래스 선언
class 클래스 이름{...}

//객체 선언 및 생성
new 클래스 이름()                 // 인스턴스 생성
const 객체명 = new 클래스 이름()  //객체 선언 및 생성



//클래스 선언
class Student{
  ...
}

// 학생 선언
const student = new Student()

// 학생 리스트 선언
const students = [
  new Student(),
  new Student(),
  new Student(),
  new Student()
]

*호이스팅 (Hoisting)-------------------------------
함수 선언과 클래스 선언의 중요한 차이점은 함수 선언의 경우 호이스팅이 일어나지만, 클래스 선언은 그렇지 않다는 것입니다.
클래스를 사용하기 위해서는 클래스를 먼저 선언 해야 합니다. 
그렇지 않으면, 다음 코드는 ReferenceError를 던질 것입니다.

const p = new Rectangle(); // ReferenceError 에러발생.

class Rectangle {}
---------------------------------------------------
함수방식
catName("Chloe");

function catName(name) {
  console.log("My cat's name is " + name);
}

/*
위 코드의 결과는: "My cat's name is Chloe"
*/

비록 함수를 작성하기 전에 함수를 호출하였지만, 코드는 여전히 동작합니다. 
이는 JavaScript에서 컨텍스트 실행이 작동하는 방식 때문입니다.
----------------------------------------------------
Hoisting은 다른 데이터 타입 및 변수와도 잘 작동함.
(변수는 선언하기 전에 초기화하여 사용될 수 있습니다. 그러나 초기화 없이는 사용할 수 없습니다.)

var x = 1; // x 초기화
console.log(x + " " + y); // '1 undefined'
var y = 2;


// 아래 코드는 이전 코드와 같은 방식으로 동작합니다.
var x = 1; // Initialize x
var y; // Declare y
console.log(x + " " + y); // '1 undefined'
y = 2; // Initialize y

에러를 내지는 않는다. 변수 선언 뒤 나중에 초기화 시키면 undefined로 뜸.
***javascript는 초기화가 아니라 선언만 끌어올린다 ====> 이게 호이스팅!!!
------------------------------------------------------

7. 생성자
- 객체를 생성하고 초기화하기 위한 메소드
- 객체가 생성될때 호출되는 것
- 클래스 기반으로 인스턴스가 생성될 때 호출되는 메소드
- "constructor"라는 이름으로 정의
- 역할
  : 속성 추가 등 객체 초기화 처리함
  
class 클래스이름{
  //생성자 정의
  constructor(){
    //객체 초기화 코드
  }
}



8. 메소드
- 객체의 속성 중 함수로 정의된 속성
- 내부적으로 메소드가 중복되지 않고 하나만 생성!!(class를 사용하는 이유!!)

*단순 객체 생성의 단점 : 객체 별로 메소드를 생성하기 때문에 무거운 자료형이 여러 번 생성.
(9-1-5.html 가 단순 객체 생성 예시)

class 클래스이름{
  메소드1 () {...}
  메소드2 () {...}
}


9. 클래스의 고급기능
- 클래스 사용 이유

단순 객체 생성의 단점
: 객체 별로 메소드르 생성하기 때문에 무거운 자료형이 여러 번 생성
: 유사한 객체를 생성하는 함수를 만들게 되면, 코드의 중복이 늘어남. 비효율적.

class 사용으로 해결.
: class에 메소드를 정의하여 사용
: 상속을 이용해서 코드의 재사용성을 높인다.



10. 상속(Inheritance)
- 부모 클래스의 속성과 메소드를 자식 클래스에서 재사용하는 것
  : 부모 클래스 : 속성과 메소드를 물려주는 클래스
  : 자식 클래스 : 속성과 메소드를 재사용하는 클래스
  : 키워드 : extends
- 상속의 장점
  : 코드 중복 최소화, 재사용성 높임, 생산 효율 높임


class 클래스이름 extends 부모클래스이름 {

}




11. private
- 클래스 내부에서만 접근하도록 지정하는 문법
- 목적 : 의도하지 않은 속성 사용 방지, 캡슐화(encapsulation)
(캡슐화 : 변수에 직접 접근하지 못하게 하여 값을 변경시킬 수 없도록 함으로써, 데이터 보호)
- 기호 : #


class 클래스이름 {
  // private 속성, 메소드 선언
  #속성이름
  #메소드이름(){

  }
}




12. getter , setter

- getter 
  : private 속성 값을 가져오는 메소드 
- setter
  : private 속성 값을 지정하는 메소드

- private 속성에 우회적으로 접근할 수 있는 방법을 제공
- 모든 private 속성에 getter,setter를 정의할 필요는 없음

사용법.
get○○() , set○○()
get 속성 () , set 속성 ()


//get○○() , set○○()
class 클래스이름 {

   #속성

   get속성(){
     return #속성
   }

   set속성(value){
     this.#속성 = value
   }

}

//get 속성 () , set 속성 ()
class 클래스이름 {

   #속성

   get 속성 (){
     return #속성
   }

   set 속성 (value){
     this.#속성 = value
   }

}






13. static (정적인, 고정적인)
- static 속성과 메소드
  : 인스턴스 생성하지 않고 사용할 수 있는 속성, 메소드
  : 클래스 이름만으로 생성되지 않은 상태에서 접근 가능.

- 사용방법
  : 클래스이름.속성
  : 클래스이름.메소드()

class 클래스이름{
  static 속성 = 값

  static 메소드 () {

  }
}



14. override
- 부모 클래스에 정의된 메소드를 자식 클래스에서 재정의.
- 자식 클래스에서 조금 다른 방법으로 확장해서 사용할 때.

- 메소드A()를 override 하지 않은 경우
  : 부모객체.메소드A()    =>    부모객체의 메소드A
  : 자식객체.메소드A()    =>    부모객체의 메소드A

- 메소드A()를 override 한 경우
  : 부모객체.메소드A()    =>    부모객체의 메소드A
  : 자식객체.메소드A()    =>    자식객체의 메소드A

- 자식 클래스에서 부모 클래스의 메소드 호출 방법
  : super.부모메소드()



